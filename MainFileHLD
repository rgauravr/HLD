
Tech stack:

Language: RxJAVA, Java
DB: postGres, mysql
Architecture: Microservices based
CI/CD: Jenkins, ansible
Docker , containers
Communications b/w services: Rest API
Version control: Git HUB


project: 

java : hashmap, internal working of hashMap, thread, odd and even thread, 4 pillar of oops,inheritance, interface,abstraction, polymorphism,hashset, overloading and overriding, exception,user defined exception, JAVA 8 , 11 feature, Optional, functional interface, types of functional interface,lambda, MARKER interface , default method, Stream based coding question, Java memory model,gc implementation in java,role of jit compiler, jde vs jre vs jvm,cloneable and Serializable interface

interface and abstraction:

why u need interface for abstraction?
why u need abstraction for interface?

SOLID priciple


HTTP Protocol

design pattern: singleton,decorator,factory, abstract pattern, aggregation and composition concept

Microservices: 
Introduction: https://www.bmc.com/blogs/microservices-architecture/
Deploy process: https://medium.com/design-microservices-architecture-with-patterns/microservices-deployments-with-containers-and-orchestrators-c693292997f9
Also read from here :
https://www.tutorialspoint.com/microservice_architecture/microservice_architecture_hands_on_soa.htm



rest api

kuber basics 
video : https://www.youtube.com/watch?v=Mn6Jc0AOUTE&t=9s&ab_channel=edureka%21
https://www.tutorialspoint.com/kubernetes/index.htm

spring boot basics

https://www.youtube.com/watch?v=UfOxcrxhC0s&t=5s&ab_channel=edureka%21
https://www.tutorialspoint.com/kubernetes/index.htm
	
============================================================================================================

How and from where to study the following topics:

1> Functional Interface and deep dive in JAVA
2> REST API and HTTP
3> Multithreading in JAVA
4> DOCKER and containers
5> Microservices

//Functional Programming in JAVA
https://github.com/the-prksh/educative-courses/tree/master/Java%208%20for%20Experienced%20Developers_%20Lambdas_%20Stream%20API%20_%20Beyond%20-%20Learn%20Interactively


//Rest API & HTTP

https://github.com/the-prksh/educative-courses/tree/master/Learn%20REST%20and%20SOAP%20API%20Test%20Automation%20in%20Java%20-%20Learn%20Interactively

//Multithreading in JAVA
https://github.com/the-prksh/educative-courses/tree/master/Java%20Multithreading%20for%20Senior%20Engineering%20Interviews%20-%20Learn%20Interactively

//DOCKER and containers
https://github.com/the-prksh/educative-courses/tree/master/Docker%20for%20Developers%20-%20Learn%20Interactively
https://github.com/the-prksh/educative-courses/tree/master/Working%20with%20Containers_%20Docker%20_%20Docker%20Compose%20-%20Learn%20Interactively

//Microservices

https://github.com/the-prksh/educative-courses/tree/master/An%20Introduction%20to%20Microservice%20Principles%20and%20Concepts%20-%20Learn%20Interactively

https://github.com/the-prksh/educative-courses/tree/master/Microservice%20Architecture_%20Practical%20Implementation%20-%20Learn%20Interactively

======================================================================================================================

How to learn system design?

Below concepts will be covered using the source video listed below:

Basics to be covered:

Topics

Client - Server Protocol
Network Protocols
Monolith & Microservices
Websockets
SSEs
gRPC
Latency
Throughput
Consistency
Availability
CAP Theorem
Synchronous, Asynchronous
PubSub (Kafka, RabbitMQ)
Proxies
Load Balancers
Caching
Service Routing
Peer to Peer
Data Storage
SQL, NoSQL
Specialised Storage Paradigms
DB Migration
Indexing
Replication
Sharding
Consistent Hashing
Horizontal, Vertical Scaling
Capacity Estimation
Polling & Streaming
Configuration
Rate Limiting
Paging & Filtering
Resiliency
Failure & Fault Tolerance
Logging & Monitoring
API Design
Security


Source:

===================================================================================================================
sudo code:
https://www.youtube.com/watch?v=FSR1s2b-l_I&list=PLTCrU9sGyburBw9wNOHebv9SjlE4Elv5a&ab_channel=sudoCODE

===================================================================================================================

Gaurav sen:
https://www.youtube.com/playlist?list=PLMCXHnjXnTnvo6alSjVkgxV-VH6EPyvoX

===================================================================================================================

coding ninja
https://www.youtube.com/watch?v=70wXrS9PeRY&list=PLrk5tgtnMN6RvXrfflstJWgcPFQ_vTOV9&ab_channel=CodingNinjas

===================================================================================================================

Striver

https://www.youtube.com/watch?v=3baWzvEDfgU&t=545s&ab_channel=Striver
https://takeuforward.org/system-design/complete-system-design-roadmap-with-videos-for-sdes/

===================================================================================================================
GitHub refrence by Interview Ready/Gaurav Sen

https://github.com/InterviewReady/system-design-resources

===================================================================================================================
Most important source

Git primer

https://github.com/donnemartin/system-design-primer

========================================================================================================================
=>The below section can be used for system design question and how to approach a problem:
refer below book and video

Then start system design with the below book

file:///C:/Users/rungtg/OneDrive%20-%20Dell%20Technologies/Desktop/System%20Design/System%20Design%20Interview%20An%20Insider%E2%80%99s%20Guide%20(Alex%20Xu)%20(Z-Library).pdf

for variation and question

file:///C:/Users/rungtg/OneDrive%20-%20Dell%20Technologies/Desktop/System%20Design/System%20Design%20the%20big%20archive%20(Alex%20Xu)%20(Z-Library).pdf


=====================================================================================================================
For all the system design question please refer the below link

https://www.linkedin.com/posts/ashishps1_i-searched-through-internet-to-find-most-activity-7113016999437365248-4f1J/?utm_source=share&utm_medium=member_android

==================================================================================================================
LEVEL wise HLD question:

https://www.linkedin.com/posts/ashishps1_study-these-45-problems-well-and-you-have-activity-7127874877377675264-VnYz/?utm_source=share&utm_medium=member_android
========================================================================================================================
How to design distributed message queue?

Source 1:
https://www.tryexponent.com/blog/distributed-message-queue-system-design-mock-interview

Source 2:
https://www.youtube.com/watch?v=iJLL-KPqBpM&ab_channel=SystemDesignInterview

========================================================================================================================

Components of System design
{

1 DNS
2 Load Balancer
3 Database
4 Key value store
5 Blob storage -> Binary large object. Stores large un structure Data.
6 CDN -> Content delivery network. Geographically distributed network to provide fast delivery of network(static content)
7 Cache -> A cache is a non persistent data storage to keep  repeatedly read/write data to provide low latency.

Video:
https://www.youtube.com/watch?v=WYNqcs0p9AY&list=PLrk5tgtnMN6RvXrfflstJWgcPFQ_vTOV9&index=9&ab_channel=CodingNinjas
}


Client - Server Protocol{

Concepts:

https://www.youtube.com/watch?v=Dg1U-jwVUrg&list=RDCMUCMrRRZxUAXRzjai0SSoFgdw&start_radio=1&rv=Dg1U-jwVUrg&t=6&ab_channel=sudoCODE
}

Monolith & Microservices{

Cocepts:
https://www.youtube.com/watch?v=qYhRvH9tJKw&ab_channel=GauravSen

Moving from MONOLITHS to MICROSERVICES:
https://www.youtube.com/watch?v=rckfN7xFig0&ab_channel=GauravSen

//blog 
https://interviewready.io/blog/monoliths-to-microservices
}

Latency{
https://sybase91.medium.com/system-design-basics-part-4-latency-throughput-and-availability-99d5e0cfaa11#:~:text=Latency%20is%20the%20time%20it,What%20are%20some%20typical%20latencies%3F&text=Throughput%20is%20the%20number%20of,handle%20properly%2C%20per%20time%20unit.
}

Throughput{
https://sybase91.medium.com/system-design-basics-part-4-latency-throughput-and-availability-99d5e0cfaa11#:~:text=Latency%20is%20the%20time%20it,What%20are%20some%20typical%20latencies%3F&text=Throughput%20is%20the%20number%20of,handle%20properly%2C%20per%20time%20unit.
}

Consistency{

Two types of consistency

1> Strong Consistency => High latency, updated read gurantee(Consistency), less availability
2> Eventual Consistency => Low latency, updated read gurantee eventually in cretain amount of time(Eventual Consistency), High availability

Video: 
https://www.youtube.com/watch?v=WZqGS-wczaY&ab_channel=ShiranAfergan

Page:
https://www.scylladb.com/glossary/eventual-consistency/

}

Distributed Caching{
https://www.youtube.com/watch?v=cCX04GXymqI&list=PLrk5tgtnMN6RvXrfflstJWgcPFQ_vTOV9&index=5&ab_channel=CodingNinjas
https://www.youtube.com/watch?v=U3RkDLtS7uY&list=PLMCXHnjXnTnvo6alSjVkgxV-VH6EPyvoX&index=12&ab_channel=GauravSen
}

Sharding{

What is sharding?
Coding Ninja
https://www.youtube.com/watch?v=nreTu-Zka94&list=PLrk5tgtnMN6RvXrfflstJWgcPFQ_vTOV9&ab_channel=CodingNinjas
sudoCode
https://www.youtube.com/watch?v=YCb-tDQWrXk&list=PLTCrU9sGyburBw9wNOHebv9SjlE4Elv5a&index=22&ab_channel=sudoCODE

Types of sharding:

Algorithm sharding
Dynamic sharding

=>Key sharding

https://www.youtube.com/watch?v=arUpleGFdt4&list=PLTCrU9sGyburBw9wNOHebv9SjlE4Elv5a&index=23&ab_channel=sudoCODE

=>Range sharding
https://www.youtube.com/watch?v=avepna2q9w0&list=PLTCrU9sGyburBw9wNOHebv9SjlE4Elv5a&index=24&ab_channel=sudoCODE

=>Directory sharding

https://www.youtube.com/watch?v=62adurZ_Muw&list=PLTCrU9sGyburBw9wNOHebv9SjlE4Elv5a&index=26&ab_channel=sudoCODE

Practical implementation of sharding using Azure

https://www.youtube.com/watch?v=zc7IyHdEdIs&ab_channel=BetterDevWithAnubhav


Article to read based on sharding for AWS and mongoDB :

https://aws.amazon.com/what-is/database-sharding/
https://www.mongodb.com/features/database-sharding-explained

}


Horizontal, Vertical Scaling{
https://www.youtube.com/watch?v=xioUCiVBjlU&list=PLrk5tgtnMN6RvXrfflstJWgcPFQ_vTOV9&index=4&ab_channel=CodingNinjas
https://www.youtube.com/watch?v=G1Z7w9_vspY&list=PLTCrU9sGyburBw9wNOHebv9SjlE4Elv5a&index=19&ab_channel=sudoCODE
https://www.youtube.com/watch?v=xpDnVSmNFX0&list=PLMCXHnjXnTnvo6alSjVkgxV-VH6EPyvoX&index=1&ab_channel=GauravSen

}

Resiliency{

https://medium.com/@ritesh.panigrahi/making-microservices-fault-tolerant-and-resilient-a2920ae156e4#:~:text=Fault%20tolerance%20means%20given%20a,some%20arrangements%20to%20handle%20failures.&text=Resilience%20means%20how%20many%20faults%20the%20system%20can%20tolerate.

https://gist.github.com/Nj-kol/d5211ed218557a6e398212838dffa3e9

}


Fault Tolerance{
https://medium.com/@ritesh.panigrahi/making-microservices-fault-tolerant-and-resilient-a2920ae156e4#:~:text=Fault%20tolerance%20means%20given%20a,some%20arrangements%20to%20handle%20failures.&text=Resilience%20means%20how%20many%20faults%20the%20system%20can%20tolerate.

https://gist.github.com/Nj-kol/d5211ed218557a6e398212838dffa3e9

}

Message Queue+Synchronous, Asynchronous+PubSub (Kafka, RabbitMQ)

{
Synchronous, Asynchronous => https://www.youtube.com/watch?v=J6CBdSCB_fY&list=PLTCrU9sGyburBw9wNOHebv9SjlE4Elv5a&index=14&ab_channel=sudoCODE

Message vs pub sub model
https://www.youtube.com/watch?v=J6CBdSCB_fY&list=PLTCrU9sGyburBw9wNOHebv9SjlE4Elv5a&index=14&ab_channel=sudoCODE

Message queue:
https://www.cloudamqp.com/blog/what-is-message-queuing.html

Example of message queue

Amazon SQS
https://aws.amazon.com/sqs/

RabbitMQ
https://www.youtube.com/watch?v=wXfKmtohjpc&ab_channel=TechnicalBabaji

pub-sub concepts:
https://www.youtube.com/watch?v=EgJ7xts82Mg&list=PLTCrU9sGyburBw9wNOHebv9SjlE4Elv5a&index=13&ab_channel=sudoCODE
https://www.youtube.com/watch?v=-vd_Ay0pvFY&list=PLTCrU9sGyburBw9wNOHebv9SjlE4Elv5a&index=13&ab_channel=sudoCODE

https://www.youtube.com/watch?v=FMhbR_kQeHw&ab_channel=GauravSen

Example of pubSub

Kafka
https://www.youtube.com/watch?v=Ch5VhJzaoaI&ab_channel=JamesCutajar

Kafka use case explained?
https://dzone.com/articles/real-time-stream-processing-with-apache-kafka-part-1

Comparing pub-sub vs message
https://www.youtube.com/watch?v=FMhbR_kQeHw&ab_channel=GauravSen
}

Load Balancers{

Concept:
Part 1: https://www.youtube.com/watch?v=kMRgNCnwt0Y&t=5s&ab_channel=ITkFunde
Part 2: https://www.youtube.com/watch?v=NSp5Z2-x6Cg&ab_channel=ITkFunde

All the basic details of Load Balancer and algorithm details

https://www.youtube.com/watch?v=QRVx6hWUZF4&t=1451s&ab_channel=ProgressKemp


OSI Model (All the 7 network Layer):
https://www.youtube.com/watch?v=sCYkeo466Qs&ab_channel=ITkFunde
}

Polling & Streaming{

Concepts: 
https://www.youtube.com/watch?v=b4qyOpGg748&t=1s&ab_channel=ByteMonk

Read polling vs streaming:
https://tech.makemytrip.com/polling-and-streaming-9eb8301d6c58

short polling vs long polling vs websocket
https://www.youtube.com/watch?v=MpNX-1ApfC4&ab_channel=MsDeepSingh

}

Websockets{

Defination: Web socket is a network-communication protocol that was specially designed to work over Transmission Control Protocol (TCP). The sockets open in a two-way channel — client and server. This creates a hotline between them leading to two endpoints. It has a different mechanism as compared to TCP/IP communication because instead of
multiple separate requests, there is a single request with the two-way transfer of data. And the most important leverage to have with the web sockets is that the connection lasts until 
either client or the server closes it or if the network drops.

Note: Websockets is used in case of streaming and server pushed the data to the client even when the client has not requested for any data.
Websockets concept:
https://www.youtube.com/watch?v=xTR5OflgwgU&ab_channel=codedamn

}


SQL, NoSQL{

=================================================================================================================
Video: 

Concepts:

DataBase basics
https://www.youtube.com/watch?v=r9HyjDALRQE&list=PLrk5tgtnMN6RvXrfflstJWgcPFQ_vTOV9&index=9&ab_channel=CodingNinjas

NoSql with respect to system design:
https://www.youtube.com/watch?v=GGIsONA1Kog&list=PLrk5tgtnMN6RvXrfflstJWgcPFQ_vTOV9&index=13&ab_channel=CodingNinjas
https://www.youtube.com/watch?v=O_c7lzNbcKo&list=PLTCrU9sGyburBw9wNOHebv9SjlE4Elv5a&index=7&ab_channel=sudoCODE


What is a NoSQL in general well explained with example:
https://www.youtube.com/watch?v=B3gJT3t8g4Q&ab_channel=ITkFunde
======================================================================================================================
Article to Read:

A Quick Overview of Different Types of Databases
https://www.astera.com/type/blog/a-quick-overview-of-different-types-of-databases/

Different Types of Databases
https://www.bitdegree.org/tutorials/types-of-databases/

ACID vs BASE

ACID => https://geeksforgeeks.org/acid-model-vs-base-model-for-database/
BASE => https://phoenixnap.com/kb/acid-vs-base
========================================================================================================================
SQL : Structure query language. structure set of data. 

Advantage of sql:

*Managing large data
*consistency
*ACID compliant
*well sctructured schema
*reduced chances of error

Disadvantage of sql:
* Not able to horizontally scale it
*data need to abide schema. If we want to add a coloumn to the existing schema . Its a bit costly.

when to use sql?
*Strict schema structure
*Data needs to be accurate
*Many to Many relationship

ACID for SQL:

A= Atomicity . Single amount of work.
C=Consistency. Data should be consistent. Multiple read to same row should be same.
I=Isolation . One transaction should be isolated from other.
D=Durability. Should be presisted on disk.
 

SQL db currenlty available?
PostGres, Mysql
=======================================================================================================================

NOSql:
Non Relational Database => Store data in document, key-value or in different representation but not in rows or coloumn.

BASE for NoSQL

*Basically Available – Rather than enforcing immediate consistency, BASE-modelled NoSQL databases will ensure availability of data by spreading and replicating it across the nodes of the database cluster.
*Soft State – Due to the lack of immediate consistency, data values may change over time. The BASE model breaks off with the concept of a database which enforces its own consistency, delegating that responsibility to developers.
*Eventually Consistent – The fact that BASE does not enforce immediate consistency does not mean that it never achieves it. However, until it does, data reads are still possible (even though they might not reflect the reality).

Adavantage:
*Schema Free
*Not to complex to handle 
*Scalable
*Higly Availabile(horizontally scaling)
*schema is easily changable

Disadvantage:
*Not relying data
*relationship between object is bit difficult
*not built for update
*Not ACID compliant
*Read times are bit slower

when to use?

========================================================================================================================
Categories of Nosql:


1> Key value based: 
eg 
Redis

Concepts of Redis:
https://www.youtube.com/watch?v=OqCK95AS-YE&ab_channel=TechWorldwithNana

Practical of Redis:
https://www.youtube.com/watch?v=OqCK95AS-YE&ab_channel=TechWorldwithNana


2>Wide coloumn based:
Cassandra DB

Concepts of Cassandra
https://www.youtube.com/watch?v=KZsVSfQVU4I&list=PL8hP5HjAnJ38Kh_tx_dazYue1xK97rSej&ab_channel=CodewithIrtiza

Practical of Cassandra (see the video in the same sequence as listed below)
https://www.youtube.com/watch?v=VsQ4OuH-K1I&ab_channel=Telusko
https://www.youtube.com/watch?v=HTuSgkDlbSA&list=PLsyeobzWxl7r0bn6dzVA8bQNxcx7DRl5F&index=3&ab_channel=Telusko
https://www.youtube.com/watch?v=Y-vY49lDeKY&list=PLsyeobzWxl7r0bn6dzVA8bQNxcx7DRl5F&index=5&ab_channel=Telusko

3>Document based:
MongoDB
Concept for MongoDB: 
https://www.youtube.com/watch?v=a8Ojk6Fnt6I&ab_channel=ITkFunde

Practical of MongoDB
https://www.youtube.com/watch?v=ofme2o29ngU&ab_channel=WebDevSimplified

4>Search Engine:
elastic search

Concept of Elastic search:
https://www.youtube.com/watch?v=Hqn5p67uev4&ab_channel=CodingExplained

Practical of Elastic(see the video in the same sequence as listed below)
https://www.youtube.com/watch?v=bcsII2dGnDU&list=PLA3GkZPtsafYd5m2BXmkL9pjsBKy0FQ2X&ab_channel=EngineeringDigest
https://www.youtube.com/watch?v=Bdt8M_RwHVs&ab_channel=EngineeringDigest
https://www.youtube.com/watch?v=6Sz5rtL1oOk&list=PLA3GkZPtsafYd5m2BXmkL9pjsBKy0FQ2X&index=6&ab_channel=EngineeringDigest


}

DB Migration{

Database migrations, also known as schema migrations, database schema migrations, or simply migrations, are controlled sets of changes developed to modify the structure of the objects within a relational database. Migrations help transition database schemas from their current state to a new desired state, whether that involves adding tables and columns, removing elements, splitting fields, or changing types and constraints.

Migrations manage incremental, often reversible, changes to data structures in a programmatic way. The goals of database migration software are to make database changes repeatable, shareable, and testable without loss of data. Generally, migration software produces artifacts that describe the exact set of operations required to transform a database from a known state to the new state. These can be checked into and managed by normal version control software to track changes and share among team members.

Eg

Flyway 

Concept of Data Base Migration and its practical approach
https://www.youtube.com/watch?v=dJDBP7pPA-o&ab_channel=RedhwanNacef
}

Indexing{

How indexing actually work?
https://www.youtube.com/watch?v=6ZquiVH8AGU&ab_channel=Concept%26%26Coding

Types of indexing:(Primary,secondary,clustering)
Part 1 : https://www.youtube.com/watch?v=tssM9hXw8xQ&ab_channel=CrackConcepts
Part 2 : https://www.youtube.com/watch?v=NgYiO6vu1zk&ab_channel=CrackConcepts
https://www.javatpoint.com/indexing-in-dbms

Commands for making sql indexing with example
https://www.geeksforgeeks.org/sql-queries-on-clustered-and-non-clustered-indexes/?ref=lbp
}

Network Protocols{

Video:
https://www.youtube.com/watch?v=JwTiZ9ENquI&list=PL6W8uoQQ2c63W58rpNFDwdrBnq5G3EfT7&index=2&ab_channel=Concept%26%26Coding

7 layer of OSI model and its protocol at each layer
https://www.youtube.com/watch?v=sCYkeo466Qs&ab_channel=ITkFunde

Network Protocol:
1>Client-server: Concept: https://www.youtube.com/watch?v=Dg1U-jwVUrg&list=RDCMUCMrRRZxUAXRzjai0SSoFgdw&start_radio=1&rv=Dg1U-jwVUrg&t=6&ab_channel=sudoCODE
   Protocol used: 
    Application Layer: 
	                  HTTP: Hypertext Transfer Protocol (HTTP) is an application-layer protocol for transmitting hypermedia documents, such as HTML. It was designed for communication between web browsers and web servers, but it can also be used for other purposes. HTTP follows a classical client-server model, with a client opening a connection to make a request, then waiting until it receives a response. HTTP is a stateless protocol, meaning that the server does not keep any data (state) between two requests.

					  Concepts:
					   https://www.geeksforgeeks.org/http-full-form/
					   
	                  Web socket: Used in a messaging/chat kind of application.
					  Defination: Web socket is a network-communication protocol that was specially designed to work over Transmission Control Protocol (TCP). The sockets open in a two-way channel — client and server. This creates a hotline between them leading to two endpoints. It has a different mechanism as compared to TCP/IP communication because instead of multiple separate requests, there is a single request with the two-way transfer of data. And the most important leverage to have with the web sockets is that the connection lasts until either client or the server closes it or if the network drops.

                      Note: Websockets is used in case of streaming and server pushed the data to the client even when the client has not requested for any data.
                      
					  Websockets concept:
                      https://www.youtube.com/watch?v=xTR5OflgwgU&ab_channel=codedamn
					  
    Transport Layer: 
	                UDP: User Datagram Protocol (UDP) is a Transport Layer protocol. UDP is a part of the Internet Protocol suite, referred to as UDP/IP suite. Unlike TCP, it is an unreliable and connectionless protocol. So, there is no need to establish a connection prior to data transfer. The UDP helps to establish low-latency and loss-tolerating connections establish over the network.The UDP enables process to process communication
					
					Concepts:
					https://www.geeksforgeeks.org/user-datagram-protocol-udp/
					
					TCP:The Internet Protocol (IP) is the address system of the Internet and has the core function of delivering packets of information from a source device to a target device. IP is the primary way in which network connections are made, and it establishes the basis of the Internet. IP does not handle packet ordering or error checking. Such functionality requires another protocol, often the Transmission Control Protocol (TCP). 
				  
  				    Concepts: https://www.khanacademy.org/computing/computers-and-internet/xcae6f4a7ff015e7d:the-internet/xcae6f4a7ff015e7d:transporting-packets/a/transmission-control-protocol--tcp
					
				    Application:
				    Used in a watching youtube videos or in a situation where we can't miss the previous video
2>Peer to Peer

   In the P2P network architecture, the computers connect with each other in a workgroup to share files, and access to internet and printers. 

   Each computer in the network has the same set of responsibilities and capabilities.
   Each device in the network serves as both a client and server.
   The architecture is useful in residential areas, small offices, or small companies where each computer act as an independent workstation and stores the data on its hard drive. 
   Each computer in the network has the ability to share data with other computers in the network.
   The architecture is usually composed of workgroups of 12 or more computers. 

   //Concepts:
   https://www.geeksforgeeks.org/what-is-p2p-peer-to-peer-process/
   https://medium.com/@nikhiljain1203/peer-to-peer-architecture-a-deep-dive-into-the-future-of-networking-d0f07945dca5

   //Application/ Practical use case of peer to peer 
   https://www.youtube.com/watch?v=2v6KqRB7adg&t=366s&ab_channel=ByteMonk
   
   Protocol used:
                 WebRTC: Use UDP protocol. Not a client server architecture.


}

Peer to Peer{

In the P2P network architecture, the computers connect with each other in a workgroup to share files, and access to internet and printers. 

Each computer in the network has the same set of responsibilities and capabilities.
Each device in the network serves as both a client and server.
The architecture is useful in residential areas, small offices, or small companies where each computer act as an independent workstation and stores the data on its hard drive. 
Each computer in the network has the ability to share data with other computers in the network.
The architecture is usually composed of workgroups of 12 or more computers. 

//Concepts:
https://www.geeksforgeeks.org/what-is-p2p-peer-to-peer-process/
https://medium.com/@nikhiljain1203/peer-to-peer-architecture-a-deep-dive-into-the-future-of-networking-d0f07945dca5

//Application/ Practical use case of peer to peer 
https://www.youtube.com/watch?v=2v6KqRB7adg&t=366s&ab_channel=ByteMonk

}
==***====Updated===

Failure and Fault{

Fault: a fault is a defect or abnormal situation in a component of a system that deviates from its specifications.
Eg Lets say there is a aeroplane which had 4 engine and if one of the engine failes then its a fault and fault will be tolerated by other 3 engine. 

Failure: A failure is when the system doesn't provide its service to the user or provides an unacceptably degraded service.
eg
when aeroplane crashes due to unfortunate situation, its an example of failure and we will use safety jacket to handle the failure.

Concepts:
https://www.youtube.com/watch?v=7vIzGmxdUvI&list=PLTCrU9sGyburBw9wNOHebv9SjlE4Elv5a&index=16&ab_channel=sudoCODE
}

Proxies{

There are 2 types of proxies:

Forward: A forward proxy, often called a proxy, proxy server, or web proxy, is a server that sits in front of a group of client machines. When those computers make requests to sites and services on the Internet, the proxy server intercepts those requests and then communicates with web servers on behalf of those clients, like a middleman.
Eg used in a college to block some website access.

Reverse: A reverse proxy is a server that sits in front of one or more web servers, intercepting requests from clients. This is different from a forward proxy, where the proxy sits in front of the clients. With a reverse proxy, when clients send requests to the origin server of a website, those requests are intercepted at the network edge by the reverse proxy server. The reverse proxy server will then send requests to and receive responses from the origin server.
eg Load Balancer

Concepts:
https://www.youtube.com/watch?app=desktop&v=4NB0NDtOwIQ&ab_channel=ByteByteGo

//Article to understad better
https://www.cloudflare.com/en-gb/learning/cdn/glossary/reverse-proxy/
}

Replication{

Concepts:
https://www.youtube.com/watch?v=RIcNswROzCc&list=PLTCrU9sGyburBw9wNOHebv9SjlE4Elv5a&index=19&ab_channel=sudoCODE

What is replication?
Data Replication is the process of storing data in more than one site or node. It is simply copying data from a database from one server to another server.

Advantage of replication/Why replication is needed?
*Availability
*Fault toleration issue
*Scalable
*High throughput

Types of algorithms for implementing Database Replication?
*Single Leader Replication
*Multi-Leader Replication
*Leaderless Replication

Single Leader Replication
-------------------------
So in leader based architecture, client (application server) requests are sent to leader DB first and after that leader sends the data changes to all of its followers as a part of the replication log.
Whenever a client wants to read data from the database then it can query either leader or any of the follower (Yes there is generally more than just one follower to make the system highly available). However, writes to the database is only accepted on the leader by the client.
Now whenever a follower dies our application will not get impacted as there is not just a single node of data. Our application can read from other followers as well and hence this makes our system highly Read Scalable

Types of replication?

Synchronous replication 
-----------------------
When changes are made to the primary database, they are immediately replicated to the replica databases before the write operation is deemed complete. This is known as synchronous replication. In other words, before the write operation is acknowledged by the primary database, the replica databases must confirm that they have received and processed the changes.  As soon as data is copied from the source database to the target database in this mode, the write operation is not deemed complete until the target database confirms that the data was received. As a result, the source database must wait for the target database’s confirmation, which ensures that the data is consistent between the source and target databases but can slow down write operations. In master-slave replication, where data consistency is crucial, synchronous replication is frequently used.

Since all changes made to the primary database are immediately reflected in the replica databases, synchronous replication ensures that there is strong consistency between the primary and replica databases. By doing this, the chance of data loss or inconsistency is decreased and the data is ensured to be consistent across all databases.

Asynchronous replication
------------------------
Changes made to the primary database do not always replicate to the replica databases in asynchronous replication, which is a type of database replication.

The changes are instead queued for later replication to the replicas. Without waiting for the target database to acknowledge receipt of the data, data is copied from the source database to the target database at a later time in this mode. Although it might lead to data inconsistency between the source and target databases, this can speed up write operations. In master-master replication, where data consistency can be attained through conflict resolution mechanisms, asynchronous replication is frequently used.

The write operation on the primary database and the update on the replica databases happen at different times in asynchronous replication. Since the data on the replica databases might not update right away to reflect changes made to the primary database, this delay could lead to momentary inconsistencies between the primary and replica databases.
As write operations can be completed quickly without waiting for confirmation from the replica databases, asynchronous replication can also benefit performance. Additionally, the write operation can still be finished on the primary database, ensuring that the system is still available if one or more replica databases are down.

Semi-synchronous replication
----------------------------
Database replication that combines aspects of synchronous and asynchronous replication is known as semi-synchronous replication. In semi-synchronous replication, modifications made to the primary database are promptly replicated to at least one replica database while other replicas may be updated asynchronously.

In this mode, which combines synchronous and asynchronous replication, the source database sends data to the target database after waiting for a predetermined amount of time or until a predetermined amount of data has accumulated. With this mode, data consistency between the source and target databases is balanced with write operation performance.

Note: Here the write operation on the primary is not deemed finished until at least one replica database certifies that the changes have been received and processed. In addition to offering better performance than fully synchronous replication, this ensures that the primary and replica databases share some degree of strong consistency
}

Logging & Monitoring{

Logging:

Logging in system design refers to the practice of recording events, messages, or activities that occur within a software application or system. These logs provide a detailed history of what has transpired, offering valuable insights into the system's behavior, performance, and potential issues. 

Read Concepts and example from kibana:
https://interviewnoodle.com/logging-in-software-design-4abbbf3dbd28
----------------------------------------------------------------------------------------------------------------------
Monitoring:
System monitoring involves the continuous monitoring of an IT system by an IT manager. It includes monitoring the performance and availability of important network devices, such as CPU, Server memory, Routers, Switches, Bandwidth, Applications.

Monitoring in system design refers to the process of observing, checking, and analyzing the behavior and performance of a system to ensure that it operates as intended and meets specified requirements. Monitoring is a crucial aspect of system design, as it allows for the identification of issues, performance bottlenecks, and potential failures in real-time or over a period.

Key aspects of monitoring in system design include:

Performance Monitoring:

Resource Usage: Tracking the utilization of system resources such as CPU, memory, disk space, and network bandwidth to ensure optimal performance.
Response Times: Measuring the time it takes for the system to respond to requests, ensuring that it meets performance expectations.
Error Monitoring:

Error Logs: Recording and analyzing error messages or log files to identify issues, troubleshoot problems, and improve system stability.
Alerts and Notifications: Setting up alerts for specific events or thresholds to notify administrators or users when something goes wrong or when predefined conditions are met.
Security Monitoring:

Intrusion Detection: Monitoring for suspicious activities or unauthorized access attempts to identify potential security threats.
Audit Trails: Keeping track of user actions and system changes to maintain accountability and detect security breaches.
Availability Monitoring:

Uptime Monitoring: Tracking the system's availability and reliability to ensure it meets service-level agreements (SLAs).
Failover and Redundancy: Monitoring failover mechanisms and redundant components to ensure high availability.
Capacity Planning:

Scalability: Monitoring the system's ability to scale and handle increased loads, helping with capacity planning to accommodate future growth.
Resource Trends: Analyzing historical data to predict future resource requirements and optimize system performance.
Application-Specific Monitoring:

Custom Metrics: Monitoring metrics specific to the application or service being run, such as transaction rates, user activity, or custom performance indicators.
User Experience Monitoring:

End-User Monitoring: Evaluating the user experience by monitoring aspects like page load times, responsiveness, and user interactions.
Effective monitoring often involves the use of specialized tools and software that collect, analyze, and visualize relevant data. These tools help system administrators and developers proactively address issues, optimize performance, and ensure the overall health and reliability of the system.
}

Paging, Filtering & Sorting{

Basics:
-------
https://www.youtube.com/watch?v=MbslvX0AMVE&t=638s&ab_channel=sudoCODE

Concepts and example
https://www.atatus.com/blog/rest-api-design-filtering-sorting-and-pagination/#filtering

Filtering:
---------
Filtering in REST API refers to the process of limiting the result set of an API request based on specific criteria.
Filtering allows clients of a REST API to retrieve only the data they need, and can be used to improve the performance of the API and reduce the amount of data transmitted over the network.

There are several ways to implement filtering in a REST API:

Path parameters
Query parameters
Request body


Sorting
-------
Sorting in REST API refers to the ability to arrange the data returned by a REST API endpoint in a specific order, either in ascending or descending order, based on one or more fields.
This allows clients to request the data in a desired order, making it easier to find what they are looking for. 

The specific sorting mechanism used by a REST API will depend on the API's design and implementation.
Ascending sorting
Descending sorting
Multiple column sorting

Paging
------
Pagination in REST API refers to the process of dividing a large number of results into smaller parts (known as pages) and sending them to the client in separate requests. This helps to manage the size of response data and reduce the amount of data that needs to be transferred over the network.
The client can request a specific page by including parameters in the API request that specify the desired page number and the number of items per page.

This approach helps to reduce network bandwidth usage and improve the speed and efficiency of API requests.
Offset Pagination
Cursor-based Pagination
Keyset Pagination
Seek Pagination


}

Data Storage{

storage type:
------------
block vs file vs object
Concept: https://www.youtube.com/watch?v=0NM1OmGQhWQ&ab_channel=AnalogiesCloud

*file storage
-------------
Concepts:
https://www.ibm.com/topics/file-storage

File storage—also called file-level or file-based storage—is a hierarchical storage methodology used to organize and store data on a computer hard drive or on network-attached storage (NAS) device. In file storage, data is stored in files, the files are organized in folders, and the folders are organized under a hierarchy of directories and subdirectories. To locate a file, all you or your computer system need is the path—from directory to subdirectory to folder to file.

Hierarchical file storage works well with easily organized amounts of structured data. But, as the number of files grows, the file retrieval process can become cumbersome and time-consuming. Scaling requires adding more hardware devices or continually replacing these with higher-capacity devices, both of which can get expensive.


Note: for windows we will use SMB protcol and for Linux we will use NFS based protocol.

=use-case:
File storage is a good solution for a wide variety of data needs, including the following:

Local file sharing: If your data storage needs are generally consistent and straightforward, such as storing and sharing files with team members in the office, consider the simplicity of file-level storage.

Centralized file collaboration: If you upload, store, and share files in a centralized library—located on-site, off-site, or in the cloud—you can easily collaborate on files with internal and external users or with invited guests outside of your network.

Archiving/storage: You can cost-effectively archive files on NAS devices in a small data center environment or subscribe to a cloud-based file storage service to store and archive your data.

Backup/disaster recovery: You can store backups securely on separate, LAN-connected storage devices. Or you can subscribe to a cloud-based file storage service to replicate your data files across multiple, geographically-dispersed data centers and gain the additional data protection of distance and redundancy.
------------------------------------------------------------------------------------------------------------------------
*block storage
---------------
Concepts:
https://www.purestorage.com/knowledge/what-is-block-storage.html#:~:text=Block%20storage%20is%20a%20type,that%20is%20stored%20in%20blocks.

Block storage is a type of data storage that uses raw storage volumes called “blocks” to store data. Commonly used in SAN, iSCSI, and local disk environments, each of these blocks can function as a stand-alone hard drive.

A block file is a type of file that is stored in blocks. Companies usually use block files when they require speedy, accurate, and efficient data transfer, such as when retrieving information from a database. Operating systems such as Linux and Windows can access the blocks via Fibre Channel over Ethernet (FCoE), Fibre Channel, or iSCSI protocols.

How Does Block Storage Work?
With block storage, each block contains a specific amount of data, typically 256KB to 4MB. Each block represents a portion of a file that isn’t organized in any specific hierarchical order. In fact, the data on blocks sitting beside neighboring blocks may be completely unrelated to each other.

Each block has its own unique identifier to differentiate it from other blocks. When a file needs to be retrieved, an application will send a request, and the blocks will be located and assembled.

Besides the identifier, the blocks don’t contain any metadata. Because of the lack of metadata, block storage is very efficient since almost all the block’s storage capacity stores the actual data. There’s no wasted space. This makes block storage ideal for workloads that require rapid scale-up and fast read/write performance.
------------------------------------------------------------------------------------------------------------------------

*object storage
---------------
//Concepts:
https://www.ibm.com/topics/object-storage\

Object storage, often referred to as object-based storage, is a data storage architecture for handling large amounts of unstructured data. This is data that does not conform to, or cannot be organized easily into, a traditional relational database with rows and columns. Today’s Internet communications data is largely unstructured. This includes email, videos, photos, web pages, audio files, sensor data, and other types of media and web content (textual or non-textual). This content streams continuously from social media, search engines, mobile, and “smart” devices.

How it works?
Objects are discrete units of data that are stored in a structurally flat data environment. There are no folders, directories, or complex hierarchies as in a file-based system. Each object is a simple, self-contained repository that includes the data, metadata (descriptive information associated with an object), and a unique identifying ID number (instead of a file name and file path). This information enables an application to locate and access the object. You can aggregate object storage devices into larger storage pools and distribute these storage pools across locations. This allows for unlimited scale, as well as improved data resiliency and disaster recovery.

Object storage removes the complexity and scalability challenges of a hierarchical file system with folders and directories. Objects can be stored locally, but most often reside on cloud servers, with accessibility from anywhere in the world.

Objects (data) in an object-storage system are accessed via Application Programming Interfaces (APIs). The native API for object storage is an HTTP-based RESTful API (also known as a RESTful Web service). These APIs query an object’s metadata to locate the desired object (data) via the Internet from anywhere, on any device. RESTful APIs use HTTP commands like “PUT” or “POST” to upload an object, “GET” to retrieve an object, and “DELETE” to remove it. (HTTP stands for Hypertext Transfer Protocol and is the set of rules for transferring text, graphic images, sound, video, and other multimedia files on the Internet).

You can store any number of static files on an object storage instance to be called by an API. Additional RESTful API standards are emerging that go beyond creating, retrieving, updating, and deleting objects. These allow applications to manage the object storage, its containers, accounts, multi-tenancy, security, billing, and more.

For example, suppose you want to store all the books in a very large library system on a single platform. You will need to store the contents of the books (data), but also the associated information like the author, publication date, publisher, subject, copyrights, and other details (metadata). You could store all of this data and metadata in a relational database, organized in folders under a hierarchy of directories and subdirectories.

But with millions of books, the search and retrieval process will become cumbersome and time-consuming. An object storage system works well here since the data is static or fixed. In this example, the contents of the book will not change. The objects (data, metadata, and ID) are stored as “packages” in a flat structure and easily located and retrieved with a single API call. Further, as the number of books continues to grow, you can aggregate storage devices into larger storage pools, and distribute these storage pools for unlimited scale.
-----------------------------------------------------------------------------------------------------------------------
*RAID

Concepts:
https://www.youtube.com/watch?v=-6sA9nHlZDc&t=868s&ab_channel=GateSmashers

Article for concepts:
https://cloud.ibm.com/docs/bare-metal?topic=bare-metal-bm-raid-levels

RAID (Redundant Array of Independent Disks) creates a single usable data disk, where several physical disks are combined into an array for better speed and fault tolerance. Following are the three key concepts in RAID:

Mirroring: copying data to more than one disk
Striping: splitting data across more than one disk
Error correction (fault tolerance): redundant data is stored to allow problems to be detected and possibly fixed.

------------------------------------------------------------------------------------------------------------------------

Architecture
*DAS: 
.Direct attach storage
.DAS is a connection between storage and a server without a storage network device.
.Block storage
.Storage is managed or accessed by a single host at any given time.
.Fast data transfer
.eg harddisk

*SAN
Concepts:
https://www.purestorage.com/uk/knowledge/what-is-storage-area-network.html

.storage area network
.A storage area network (SAN) is a dedicated network of storage devices used to provide a pool of shared storage that multiple computers and servers can access. Storing data in centralized shared storage architecture like SANs allows organisations to manage storage from a collective place and apply consistent policies for security, data protection, and disaster recovery.
.it is  a high speed network that provides multiple server access to consolidated pools of shared , block level storage.
.it consist of host ,switches, storage elements and storage devices that are interconnected using a variety of technologies,topology and protocols
.it represents a storage device to a host such that the storage appear to be a locally attached.
.Improve application availability, enhance application performance and it support heavy read/write.

*NAS
Concept:
https://www.purestorage.com/knowledge/what-is-nas.html

.Networked Attached Storage (NAS) is a dedicated file storage system that allows multiple users and devices on the local area network (LAN) to access data from a centralized storage area on the network. Users can access NAS using a standard ethernet connection via a router or a network switch.
.NAS is an easy-to-use storage system with high storage capacity and low costs. Network-attached storage systems are flexible and scalable, allowing you to add additional storage when necessary.
.It is a storage device that connects to a network and provide file access service to a computer systems in LAN(TCP/IP)
.these devices generally consist of an engine that implements the file services and or more devices, on which data is stored
.NAS uses file access protocol such as NFS(Linux based) or SMB(Windows)
.Simplified solution 



}

Specialised Storage Paradigms{

special types of storage:
//https://www.youtube.com/watch?v=ftEWQPDlTDA&ab_channel=ByteMonk

*BLOB
------
.Blob means binary large object. It’s a collection of raw binary data. Therefore, it consists of zeros and ones.
While blobs could be structured or semi-structured data, they are often large unstructured data. Examples of blobs include media files such as audio and video files, PDFs, log files, emails, images, etc.
.Eg : Amazon S3, Google cloud storage
Article for concepts:
https://www.baeldung.com/cs/blob-storage
----------------------------------------------------------------------------------------------------------------------

*HDFS 
-----
Concepts:
https://www.youtube.com/watch?v=VavRifvVwIo&ab_channel=GateSmashers
s3(Blob) vs HDFS 
https://www.youtube.com/watch?v=rqCJjanWMQ4&ab_channel=MelvinL
eg Amazon EBS
It provides one of the most reliable filesystems. HDFS (Hadoop Distributed File System) is a unique design that provides storage for extremely large files with streaming data access pattern and it runs on commodity hardware. Let’s elaborate the terms:  
Extremely large files: Here we are talking about the data in range of petabytes(1000 TB).
Streaming Data Access Pattern: HDFS is designed on principle of write-once and read-many-times. Once data is written large portions of dataset can be processed any number times.
Commodity hardware: Hardware that is inexpensive and easily available in the market. This is one of feature which specially distinguishes HDFS from other file system.

Nodes: Master-slave nodes typically forms the HDFS cluster. 

Two main components:
NameNode(MasterNode):
.It record the metadata of all the file store in the cluster. eg The location of blocks stored,the size of files,permission hierarchy etc. These are the two files associated with the metadata:
.FsImage: It contains the complete state of the file system name space Since the start of the nameNode
.EditLogs: It contains all the recent modification made to the file system with respect to the most recent fsImgae.
.It regularly receives the heartbeat and a block report from all the datanode in the cluster to ensure that the datanodes are live.

DataNode(slave):
.The actual data is stored in dataNode.
.The dataNode perform the low-level read and write request from the file system client.

----------------------------------------------------------------------------------------------------------------------
*time series - influxDB (use to store data related to timestamp. Eg crypto currency data)
*RDBMS - see above sql vs Nosql
*NO-Sql DB - see above sql vs Nosql

*Graph-DB - neo4j
-----------------
Concepts:
https://www.youtube.com/watch?v=3C48rm9H4DI&ab_channel=TechPrimers
Practical of GraphDB
https://www.youtube.com/watch?v=NvjKXwt7n48&ab_channel=CodeWithHarry

.A graph database (GDB) is a database that uses graph structures to store data. 
 It uses nodes, edges, and properties instead of tables or documents. The edges represent relationships between the nodes. This helps in retrieving data more easily

When do we need Graph Database?
.It solves Many-To-Many relationship problems
.When relationships between data elements are more important
.Low latency with large scale data
----------------------------------------------------------------------------------------------------------------------
}

Security{
We dive into three parts of security

1> Verification
 
 Types of Verification:
   *Captcha:
     Defination: 
	  Captcha verification (or Completely Automated Public Turing Test to tell Computers and Humans Apart) is a common web technique used to help ensure that your respondents are real humans and not a program written to spam your survey. In a captcha verification, the respondent is presented with a picture (or “challenge”) of words or characters, and the respondent must correctly type out those characters in order to proceed.
	  Captcha is a third-party service provided by Google. No respondent information is sent to Google as part of this service. Visit Google’s reCAPTCHA page to learn more. It’s also important to note that not all languages are supported by this feature, and that supported languages are owned and decided upon by Google. See Google’s documentation for more details.
	 
	  Video: https://www.youtube.com/watch?v=5ge3vM4JjLg&ab_channel=TechnicalSagar
   
   *SSL/TLS(Secure Socket Layer/Transport Layer security)
    SSL: 
	Concepts: https://www.cloudflare.com/en-gb/learning/ssl/what-is-ssl/
	 * In order to provide a high degree of privacy, SSL encrypts data that is transmitted across the web. This means that anyone who tries to intercept this data will only see a garbled mix of characters that is nearly impossible to decrypt.
     * SSL initiates an authentication process called a handshake between two communicating devices to ensure that both devices are really who they claim to be.
     * SSL also digitally signs data in order to provide data integrity, verifying that the data is not tampered with before reaching its intended recipient.
	 
	 TLS:
	  Concepts: https://www.cloudflare.com/en-gb/learning/ssl/transport-layer-security-tls/
	  Transport Layer Security, or TLS, is a widely adopted security protocol designed to facilitate privacy and data security for communications over the Internet. A primary use case of TLS is encrypting the communication between web applications and servers, such as web browsers loading a website. TLS can also be used to encrypt other communications such as email, messaging, and voice over IP (VoIP).
   
     
   

2>Authentication
Defination: In simple terms, authentication is the process of verifying who a user is, while authorization is the process of verifying what they have access to.

Comparing these processes to a real-world example, when you go through security in an airport, you show your ID to authenticate your identity. Then, when you arrive at the gate, you present your boarding pass to the flight attendant, so they can authorize you to board your flight and allow access to the plane.

Types:
   =>Single Sign On
    Concept: Single Sign-On (SSO) is an authentication method that lets users access multiple applications and services using a single set of login credentials. SSO can help businesses improve user satisfaction and productivity, strengthen access security, and reduce IT operations expense and complexity.
	//Link: https://www.cyberark.com/what-is/sso/#:~:text=Single%20Sign%2DOn%20(SSO)%20is%20an%20authentication%20method%20that,IT%20operations%20expense%20and%20complexity.
     Two protocol: 
	   *SAML-based SSO 
		 Concept: Security Assertion Markup Language, or SAML, is a standardized way to tell external applications and services that a user is who they say they are. SAML makes single sign-on (SSO) technology possible by providing a way to authenticate a user once and then communicate that authentication to multiple applications. The most current version of SAML is SAML 2.0. 
		 //Link: https://www.cloudflare.com/en-gb/learning/access-management/what-is-saml/
		 //Video: https://www.youtube.com/watch?v=O1cRJWYF-g4&ab_channel=ByteByteGo
		 
	   *OpenID: .OpenID is an open specification for authentication and single sign-on (SSO). It was created in 2005 
	            to allow websites and authentication services to exchange security information in a standardized way.
	            .OpenID Connect (OIDC) is a protocol built on top of the OAuth 2.0 framework. It allows individuals to use SSO to access relying party sites using OpenID Providers (OPs). OPs can be email providers or social networks.

   =>User Tokens:
      Token-based authentication is a protocol which allows users to verify their identity, and in return receive a unique access token. During the life of the token, users then access the website or app that the token has been issued for, rather than having to re-enter credentials each time they go back to the same webpage, app, or any resource protected with that same token.
	  
	   Link: https://www.geeksforgeeks.org/how-does-the-token-based-authentication-work/

   =>OAuth Authorization abused for authentication!)
     . It stands for open Authorization
	 .OAuth, or Open Authorization, is a standard for access delegation. It allows users to grant applications or   websites access to their information on other sites without giving them their passwords.
	 .OAuth is an open-standard authorization framework that enables third-party applications to gain limited access to user’s data.
	 eg  For example, you can tell Facebook that it’s OK for ESPN.com to access your profile or post updates to your timeline without having to give ESPN your Facebook password
	 .A  classic example of valet parking is often retold to understand this concept. In this case, the car owner has access to both the car and the valet. To have his car parked for him, the car owner gives the valet key to the attendant. The valet key starts the car and opens the driver’s side door but prevents the valet from accessing valuables in the trunk or glove box.
	 //Concepts Link:
       Video: https://www.youtube.com/watch?v=O8sgkKRIZyo&ab_channel=BittenTech
	   Page: https://www.geeksforgeeks.org/workflow-of-oauth-2-0/
	         https://www.csoonline.com/article/562635/what-is-oauth-how-the-open-authorization-framework-works.html
   
   =>Oauth 2.0
     *OAuth 2.0, or "Open Authorization", is a standard that allows a website or application to access resources on behalf of a user. It's the industry standard for online authorization.
	 *OAuth 2.0 allows users to share specific data with an application while keeping their usernames, passwords, and other information private. For example, an application can use OAuth 2.0 to obtain permission from users to store files in their Google Drives.
	 //Concepts: https://www.digitalocean.com/community/tutorials/an-introduction-to-oauth-2
       Video: https://www.youtube.com/watch?v=65-6asTjuB8&t=356s&ab_channel=GauravSen
	   
3>Authorization
Defination: In simple terms, authentication is the process of verifying who a user is, while authorization is the process of verifying what they have access to.

Comparing these processes to a real-world example, when you go through security in an airport, you show your ID to authenticate your identity. Then, when you arrive at the gate, you present your boarding pass to the flight attendant, so they can authorize you to board your flight and allow access to the plane.

Authentication vs. Authorization
 Concepts: 
 https://www.youtube.com/watch?v=B76BhEq1FN8&t=5s&ab_channel=EngineeringDigest
 https://auth0.com/docs/get-started/identity-fundamentals/authentication-and-authorization

Types:
   Access Control Lists:
    .An access control list includes a set of rules used to assign permissions or grant different levels of access to files and business-critical information.
	.Organizations can use access control lists (ACL) to secure data. One of the major reasons to use access control lists is to restrict unauthorized users from accessing business-sensitive information. It can also be used to control network traffic by limiting the number of users accessing files, systems, and information. This increases network performance and helps protect business information.
	.Advantages of using an ACL:
      -Help enhance network performance by limiting network traffic
      -Provide security by defining permission and access rights
      -Offer granular control over the traffic flow entering the network
	  
	Concepts:https://www.solarwinds.com/resources/it-glossary/access-control-list-acl
	Video:https://www.youtube.com/watch?v=ffB9i05VxVo&ab_channel=SheshChauhanITTrainer

   Rule Engines:
     .A rules engine is a software that uses a set of rules to determine if a user or resource has permission to perform an action. Rules engines are useful for handling complex authorization requirements.
	 .Rules engines are often implemented as if statements. For example, a basic rule might be "If A, then B, else if X, then do Y". 
     .Rules engines can handle multiple objects and rules efficiently. They are especially useful when there are many possible outcomes based on different conditions and criteria.
	 Concepts: https://medium.com/@er.rameshkatiyar/what-is-rule-engine-86ea759ad97d

}

Rate Limiting{

Concept: https://www.youtube.com/watch?v=YSW3UE5AFD4&t=60s&ab_channel=sudoCODE
         https://www.youtube.com/watch?v=qUydEBZmGvU&t=124s&ab_channel=ByteMonk

Practical execution using JAVA and spring 
  : https://www.youtube.com/watch?v=0LoqPg6h6wc&list=PLTyWtrsGknYdZlO7LAZFEElWkEk59Y2ak&index=49&ab_channel=TechPrimers
  
Rate limiting is a technique that controls the rate at which requests are made to a server, network, or other resource. It's used to ensure that resources are available to all users and to prevent excessive or abusive use

Different algorithm:

*Reduce Parallelism
-------------------
Queueing, or blocking requests, is the most basic way to control and manage parallelism. This method is not rate limiting per se but rather a way to control parallelism. It works by blocking or waiting for the previous request to finish before moving on to the next request. This is a great method to manage the number of concurrent requests.

The advantage of this technique is that, besides controlling parallelism, it’s also cheaper, as you don’t need a more sophisticated solution that implements rate limiting algorithms. However, this has a significant disadvantage: it doesn’t guarantee that all the requests will be serviced in a certain time period.

*Constant Rate Limiting (Throttling)
-----------------------------------
Constant rate limiting means that all requests are limited to the same number of allowed requests per unit of time. In other words, the system will allow the same number of requests every hour, every day, or every minute.
The main advantage of throttling is its simplicity: it’s straightforward to implement and easy to enforce. The main disadvantage is that while it can control the number of requests, it can’t control the amount of data transferred per request. For example, if you allow 100 requests per hour, which is 100KB, but one request transfers 2MB, you’ll get only one request per hour.

Generic Cell Rate Algorithm (GCRA)
---------------------------------
The Generic Cell Rate Algorithm (GCRA) is one of the most commonly used. It works by dividing time into cells of a certain size (usually one second). Each time a request is made, a new cell is created. If the number of requests in a cell exceeds the limit, all subsequent requests are blocked until the next cell.
GCRA is a fairly simple and effective algorithm, but it can be improved upon. One issue is that tuning the cell size to the desired limit can be challenging. If the cell size is too large, then there will be too much variability in the rate (some cells may be well below the limit while others are well above it). If the cell size is too small, the rate will be too low. Another issue is that GCRA only works on a per-second basis. This can be problematic if the rate limit is very low (such as one request per minute). In this case, a more sophisticated algorithm is needed.

Leaky Bucket
------------
The leaky bucket rate limiting algorithm is a system that uses a fixed-size bucket with a hole. The bucket can hold a specific number of tokens, and each token represents one request to your API. The tokens are added to the bucket by the user and are removed from the bucket by the server.
The token bucket is a great solution for straightforward rate limiting. The advantage of the leaky bucket rate limiting algorithm is that it’s easy to implement and maintain. However, it has a significant disadvantage: It doesn’t allow for adjustments for the length of time that it takes the user to make a request. The token bucket only allows for a fixed number of tokens per time.

Fixed Window
------------	
Fixed window rate limiting uses a fixed-size sliding window. The window represents a fixed period of time, usually one or two hours, which slides every time a request is made. The advantage of this rate-limiting algorithm is that it lets you control the amount of data transferred per request. The disadvantage of this rate-limiting algorithm is that it’s hard to understand and implement, the window needs to be of the right size, and it doesn’t guarantee that all the requests will be serviced in a certain period of time. The fixed window rate limiting algorithm is used to control the amount of data per request.

Sliding Log or Sliding Window
-----------------------------
The sliding log rate limiting algorithm uses the SLA table, which logs the user’s activities. The table contains the users’ IP addresses and the activities logged against them. The advantage of this rate-limiting algorithm is that it can control the number of requests per unit of time and the amount of data transferred per request. The disadvantage of the sliding log rate limiting algorithm is that it’s hard to implement and understand and makes it hard for a new user to determine how to use it. It also doesn’t guarantee that all requests will be serviced within a certain time.


}

API throttling{

API throttling is the process of limiting the number of API requests a user can make in a certain period. An application programming interface (API) functions as a gateway between a user and a software application. For example, when a user clicks the post button on social media, the button click triggers an API call. This API interacts with the web server of the social media application and performs the action of posting. This user could be a human or another software application.

Concepts: 
  https://www.tibco.com/reference-center/what-is-api-throttling
  
Difference between Rate Limiting vs API throtling
-------------------------------------------------
https://nordicapis.com/api-rate-limiting-vs-api-throttling-how-are-they-different/#:~:text=Rate%20limiting%20is%20a%20mechanism,rate%20limit%20an%20entire%20server.

}

Configuration{
Concepts: https://www.enjoyalgorithms.com/blog/configurations-management

Configuration in system design is a type of design that involves combining a set of predefined components in specific ways to create a system. The components are physical devices that are typically selected from a manufacturer's catalog. The assembly of components must meet a set of requirements and adhere to a set of constraints. 
In terms of computers and technology, configuration refers to the arrangement of an IT system's hardware and software. Managing the components and settings ensures that all IT systems can function smoothly.

}

SSEs{

//Concepts: https://www.enjoyalgorithms.com/blog/server-sent-events/
//Video concepts including implementation:
https://www.youtube.com/watch?v=4HlNv1qpZFY&t=1s&ab_channel=HusseinNasser

.Server-Sent Events (SSE) is a technology that allows a client to automatically receive updates from a server via an HTTP connection. 
.With SSE, a client doesn't need to poll the server for new updates. Instead, the server can initiate data transmission towards clients once an initial client connection has been established.
.SSE is used in real-time projects to send messages or updates from the server to the client. For example, a web page can automatically get updates from a server
.eg notification system, Used in uber where rider will be notified in case any cab is available.
}

Heart Beat{

Concept: https://www.youtube.com/watch?v=DoMkgzZXcPc&ab_channel=ClouDNS
Article to read: https://www.cloudns.net/wiki/article/394/

Heartbeat monitoring (also known as Cron Job Monitoring) is a great way to monitor servers/computers/devices which are connected to the internet. It is a time-tested method of tracking the health of a device or software system by sending regular heartbeat events to a remote Monitoring Service.

How does Heartbeat Monitoring work?
It works in an opposite way compared to the other monitoring types as it requires the monitor to send the requests so that our monitoring system can decide if it is UP or DOWN. Once a monitor has been created, it will be marked with DOWN state, until it receives its first heartbeat event. A heartbeat event can be simply made by making a GET or POST request to the specially generated Heartbeat URL.

}

Service Discovery{

Concept: https://www.youtube.com/watch?v=3UDJvF0CMkQ&t=59s&ab_channel=sudoCODE
Article: https://www.nginx.com/blog/service-discovery-in-a-microservices-architecture/

Service discovery is the process of automatically detecting devices and services on a computer network. It helps to reduce the amount of manual configuration required from users and administrators

Why Use Service Discovery?
-------------------------
Service instances have dynamically assigned network locations. Moreover, the set of service instances changes dynamically because of autoscaling, failures, and upgrades. Consequently, your client code needs to use a more elaborate service discovery mechanism.

Discovery pattern
-----------------
There are two main service discovery patterns: client‑side discovery and server‑side discovery. Let’s first look at client side discovery.

The Client‑Side Discovery Pattern
---------------------------------

When using client‑side discovery, the client is responsible for determining the network locations of available service instances and load balancing requests across them. The client queries a service registry, which is a database of available service instances. The client then uses a load‑balancing algorithm to select one of the available service instances and makes a request.
The network location of a service instance is registered with the service registry when it starts up. It is removed from the service registry when the instance terminates. The service instance’s registration is typically refreshed periodically using a heartbeat mechanism.
eg
Netflix OSS provides a great example of the client‑side discovery pattern

The Server‑Side Discovery Pattern
---------------------------------

The client makes a request to a service via a load balancer. The load balancer queries the service registry and routes each request to an available service instance. As with client‑side discovery, service instances are registered and deregistered with the service registry.

The AWS Elastic Load Balancer (ELB) is an example of a server-side discovery router. An ELB is commonly used to load balance external traffic from the Internet. However, you can also use an ELB to load balance traffic that is internal to a virtual private cloud (VPC). A client makes requests (HTTP or TCP) via the ELB using its DNS name. The ELB load balances the traffic among a set of registered Elastic Compute Cloud (EC2) instances or EC2 Container Service (ECS) containers. There isn’t a separate service registry. Instead, EC2 instances and ECS containers are registered with the ELB itself.

The Service Registry
--------------------
The service registry is a key part of service discovery. It is a database containing the network locations of service instances. A service registry needs to be highly available and up to date. Clients can cache network locations obtained from the service registry. However, that information eventually becomes out of date and clients become unable to discover service instances. Consequently, a service registry consists of a cluster of servers that use a replication protocol to maintain consistency.

Netflix Eureka is good example of a service registry.

There are a couple of different ways to handle the registration and deregistration. One option is for service instances to register themselves, the self‑registration pattern. The other option is for some other system component to manage the registration of service instances, the third‑party registration pattern.

The Self‑Registration Pattern
-----------------------------

When using the self‑registration pattern, a service instance is responsible for registering and deregistering itself with the service registry. Also, if required, a service instance sends heartbeat requests to prevent its registration from expiring.
A good example of this approach is the Netflix OSS Eureka client.

The Third‑Party Registration Pattern
------------------------------------

When using the third-party registration pattern, service instances aren’t responsible for registering themselves with the service registry. Instead, another system component known as the service registrar handles the registration. The service registrar tracks changes to the set of running instances by either polling the deployment environment or subscribing to events. When it notices a newly available service instance it registers the instance with the service registry. The service registrar also deregisters terminated service instances.

example of a service registrar is NetflixOSS Prana
}

Event driven system{

//Source: 
   v1:https://www.youtube.com/watch?v=vGOEO6mO674&list=PLTCrU9sGyburHcVKRuw2yXt7V7HEa6ZYY&index=3&ab_channel=sudoCODE
   v2:https://www.youtube.com/watch?v=bpP4GX8oxjk&list=PLTCrU9sGyburHcVKRuw2yXt7V7HEa6ZYY&index=4&ab_channel=sudoCODE
//Article to read:
https://www.baeldung.com/cs/eda-software-design#:~:text=Event%2Ddriven%20architecture%20(EDA),and%20real%2Dworld%20use%20cases.

Defination:
Event-driven architecture is a dynamic approach that orchestrates software systems based on real-time events and interactions. Unlike conventional architectures, EDA fosters a decentralized model of communication characterized by loosely coupled components that respond to events. Thus, EDA transforms traditional monolithic structures into agile, event-responsive ecosystems.

For instance, consider a retail application utilizing EDA. When a customer places an order, an event is triggered, setting off a chain of actions. This could involve updating inventory, processing payments, and notifying the customer. In other words, EDA ensures that every step is initiated by relevant events, resulting in a streamlined and efficient process.

Furthermore, EDA enables systems to handle complex scenarios with ease. Let’s say an intelligent home system detects a sudden temperature drop. Through EDA, this event can trigger multiple responses: adjusting the thermostat, notifying the homeowner, and activating heating devices. Such specific and simultaneous reactions exemplify the power of EDA.

}

Consistency Hashing{

Defination:
-----------
Consistent hashing is a distributed systems technique that operates by assigning the data objects(keys) and nodes(server) a position on a virtual ring structure (hash ring). Consistent hashing minimizes the number of keys to be remapped when the total number of nodes changes.

It is used in the following scenario:
------------------------------------
Database sharding
-----------------
when we are doing the horizontal sharding then the number of database node keeps on increasing or decreasing based on the number of incoming data load. so here we can use Consistent hashing to handle the dynamically changing data base node.

Load balancer
------------
It will used in a situation where number of server/nodes are dynamically changing.

Topic to read
-------------
>What is hashing?
>problem with hashing?
>why need cosistency hashing?
>How cosistency hashing works?

All of the above topic will be cleared in :
------------------------------------------
Video sequence: 
v1 ->  https://www.youtube.com/watch?v=cITtFpz3a3Y&list=PLTCrU9sGyburBw9wNOHebv9SjlE4Elv5a&index=25&ab_channel=sudoCODE
v2 -> https://www.youtube.com/watch?v=oKAU6LaYFhw&list=PLTCrU9sGyburBw9wNOHebv9SjlE4Elv5a&index=27&ab_channel=sudoCODE

<Optional> v3 -> https://www.youtube.com/watch?v=jqUNbqfsnuw&ab_channel=Concept%26%26Coding

Article to read:
----------------
https://www.enjoyalgorithms.com/blog/consistent-hashing-in-system-design/
<optional> https://www.toptal.com/big-data/consistent-hashing

Simple implementation of consistent hashing:
--------------------------------------------
https://ishan-aggarwal.medium.com/consistent-hashing-an-overview-and-implementation-in-java-6b47c718558a
}

gRPC{

Video : https://www.youtube.com/watch?v=iv9ylBYgACE&ab_channel=TechPrimers
Article: https://grpc.io/docs/what-is-grpc/introduction/

gRPC is an open-source API architecture and system that uses the Remote Procedure Call (RPC) model. It's a way to send data across networks. gRPC can be used to communicate between services in a microservice architecture.
It uses protocol buffer to transfer the data from client to server or vice versa.

Overview
--------
In gRPC, a client application can directly call a method on a server application on a different machine as if it were a local object, making it easier for you to create distributed applications and services. As in many RPC systems, gRPC is based around the idea of defining a service, specifying the methods that can be called remotely with their parameters and return types. On the server side, the server implements this interface and runs a gRPC server to handle client calls. On the client side, the client has a stub (referred to as just a client in some languages) that provides the same methods as the server.
gRPC clients and servers can run and talk to each other in a variety of environments - from servers inside Google to your own desktop - and can be written in any of gRPC’s supported languages. So, for example, you can easily create a gRPC server in Java with clients in Go, Python, or Ruby. In addition, the latest Google APIs will have gRPC versions of their interfaces, letting you easily build Google functionality into your applications

Working with Protocol Buffers
-----------------------------
By default, gRPC uses Protocol Buffers, Google’s mature open source mechanism for serializing structured data (although it can be used with other data formats such as JSON).
he first step when working with protocol buffers is to define the structure for the data you want to serialize in a proto file: this is an ordinary text file with a .proto extension. Protocol buffer data is structured as messages, where each message is a small logical record of information containing a series of name-value pairs called fields. Here’s a simple example:

message Person {
  string name = 1;
  int32 id = 2;
  bool has_ponycopter = 3;
}

}

Availability{
//Source: https://www.geeksforgeeks.org/availability-in-system-design/
          https://www.enjoyalgorithms.com/blog/availability-system-design-concept/
Defination
----------
In system design, availability refers to the proportion of time that a system or service is operational and accessible for use. It is a critical aspect of designing reliable and resilient systems, especially in the context of online services, websites, cloud-based applications, and other mission-critical systems.

How is availability measured?
-----------------------------
Availability is usually measured as a percentage and is often expressed in terms of “uptime” versus “downtime” over a given period. For instance, a system with 99% availability means it is expected to be operational and accessible 99% of the time, while the remaining 1% represents the allowable downtime.

How do we achieve high availability?
-----------------------------------
>Redundancy: Employ redundant components or servers to ensure that another can take over seamlessly if one fails. This can include redundancy at different levels, such as hardware, networking, and data centers.
>Load balancing: Distributing incoming requests across multiple servers or resources to prevent overload on any single component and improve overall system performance and fault tolerance.
>Failover mechanisms: Implementing automated processes to detect failures and switch to redundant systems without manual intervention.
>Disaster Recovery (DR): Having a comprehensive plan in place to recover the system in case of a catastrophic event that affects the primary infrastructure.
>Monitoring and Alerting: Implementing robust monitoring systems that can detect issues in real-time and notify administrators to take appropriate action promptly.
>Performance optimization: Ensuring that the system is designed and tuned to handle the expected load efficiently, reducing the risk of bottlenecks and failures.
>Scalability: Designing the system to scale easily by adding more resources when needed to accommodate increased demand.

}

CAP Theorem{

Concepts 
v1: https://www.youtube.com/watch?v=pSoKUfLTe8Y&list=PLTCrU9sGyburBw9wNOHebv9SjlE4Elv5a&index=19&ab_channel=sudoCODE 
v2: https://www.youtube.com/watch?v=kwCFHLbIhak&list=PLTCrU9sGyburBw9wNOHebv9SjlE4Elv5a&index=22&ab_channel=sudoCODE

Artcile to read: https://medium.com/nerd-for-tech/cap-theorem-with-focus-on-partition-tolerance-1af4403cb35a
                 https://www.enjoyalgorithms.com/blog/cap-theorem-in-system-design/
Defination:
-----------
CAP theorem also known as Brewer’s theorem is a concept used for distributed systems. It says that any distributed system provides only 2 guarantees out of the three (C, A & P) . This theorem is used by System Designers to choose the best architecture when designing distributed systems.
A distributed system is a system with multiple components located on different machines that communicate and coordinate actions in order to appear as a single logical system to the end-user.

Consistency
-----------
Every read receives the most recent write. If there are multiple parallel writes and reads in the system, every read will always return the correct write or the last write done on the system.
So if there are 2 nodes which are being used for read, then both the nodes should be consistent with each other so that the correct value is fetched.

Availability
------------
Availability in a distributed system ensures that the system remains operational 100% of the time. Every request gets a response(non error) regardless of the individual state of the node. This does not guarantee that the response contains the most recent write(Consistency).

Partition Tolerance
-------------------
Partition Tolerance means that as a system your entire application should always work. There could be two nodes in the system losing connection between them. However the nodes will function normally for other tasks; just that the two nodes themselves will not be able to communicate to each other.

Example
-------
The examples are based on Master-Master and Master-Slave architecture. So please read this:

DB Master Master architecture :
-----------------------------
In master-master architecture we can have multiple masters across regions. As we have multiple masters, so the read and write operation can both be done in any of the master nodes.

DB Master Slave architecture :
-----------------------------
In Master Slave architecture, we have only 1 master and all the other nodes are slave. So we choose the master node for all write operations, and the other slave nodes are means to serve the purpose of read operations. It’s the responsibility of master node to notify all slaves of the write operations.

Now to understand Partition Tolerance, we will take the above concepts of master-master and master-slave as examples.

Master-Master
-------------
Say that we have 2 nodes in total. Both are masters. The application is making a read & write operation in both the nodes. Assume, there are other applications using these nodes just for read purposes. Let’s name the nodes as A and B. If the application makes a write operation in A, it is A’s responsibility to notify B about the write operation; and vice versa. What if there’s an issue in connectivity of A and B. The A and B nodes work fine , just that they are not able to communicate in between them. This is what Fault tolerance is. Node A and B will not be able to notify each other about the write operations.

In this case, we can either choose Availability or we can choose Consistency.

Availability — If we let both A and B work, there cannot be consistency as A and B would not know about the changes that are being made to the respective nodes, as there’s no connection between them. However, the nodes A and B will be available. We have availability, not consistency.

Consistency — If we remove one of the master node say A; then the system will be consistent as there’s no need of communication about writes as only a single node is present. However we are compromising on Availability, as only a single node is available now. Hence we have Consistency, but not availability

Master-Slave
------------
This should be clear based on the above explanation.
In this case if we lose a connection between a master and a slave. The slave will never know about the write operations performed on master. Right ? So if we remove the node from the system, then we have consistency but not availability. And if we let the slave node be available despite of the connection not present between the node and master; then we have the availability but not consistency.

}
Capacity Estimation{

//Concept: https://www.youtube.com/watch?v=VBw703pjC3E&list=PLTCrU9sGyburBw9wNOHebv9SjlE4Elv5a&index=28&ab_channel=sudoCODE

Power of 2
----------
2^0 = 1
2^1 = 2
2^2 = 4
2^3 = 8
2^4 = 16
2^5 = 32
2^6 = 64
2^7 = 128
2^8 = 256
2^9 = 512
2^10 = 1024
2^11 = 2048
2^12 = 4096

metric system
-------------
1 lakh = 10^5
1 crore = 10^7
1 million = 10^6
1 billion = 10^9
1 trillion = 10^12

storage capacity
----------------

1 B = 8 bits
1 KB = 1024 B
1 MB = 1024kb
1 gb = 1024mb
1 TB = 1000GB
1 PB = 1000TB

Transaction
-----------

1 million transaction/day = 10^6/24*60*60 ~ 12/sec;
1 million transaction/day = 700/min
1 million transaction/day = 4200/hr

Rounding off
------------

> Try to round off the number in power of 10 or nearest to the power of 2
eg 980 should be rounded off to 1000
   63 should be rounded of to 64 which is power of 2.
   
Capacity estimation should be done in the following scenario:
-------------------------------------------------------------
* Number of read and write to understand if the system is read heavy or write heavy.
* Number of transaction
* Huge data transfer
* Network bandwidth
* Number of update operation in case of people posting photos/videos in facebook. 
}

//OverAll all the important system design concept/components under one roof and their linking.
//VVI
//To solve any HLD question this is the basics to start with:
//First do these one and then do the system design question.
{
// Concepts => Video: https://www.youtube.com/watch?v=rExh5cPMZcI&list=PL6W8uoQQ2c63W58rpNFDwdrBnq5G3EfT7&index=6&ab_channel=Concept%26%26Coding
 1> Single Server
 2> Application Server and DB server seperation.
 3> Load balancer and multi app server
 4> Database replication
 5> Cache
 6> CDN (All CDN is a cache but all Cache is not a CDN. Eg reddis is a cache but not a CDN)
 7>Data center
 8> Messaging queue
 9> Database scaling/sharding.
 10> Consistent hashing
}

API Design


8810782767/2

test charge alag
